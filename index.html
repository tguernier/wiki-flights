<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wikipedia Flights Map</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            color: #fff;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            padding: 20px 0 30px;
        }

        h1 {
            font-size: 2.5rem;
            font-weight: 300;
            margin-bottom: 8px;
            background: linear-gradient(90deg, #00d4ff, #7b2cbf);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            color: #8892b0;
            font-size: 1rem;
            margin-bottom: 20px;
        }

        .search-container {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
            position: relative;
        }

        .search-input {
            padding: 12px 20px;
            font-size: 1rem;
            width: 100%;
            max-width: 400px;
            background: rgba(15, 23, 42, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: #fff;
            outline: none;
            transition: all 0.3s ease;
        }

        .search-input:focus {
            border-color: #00d4ff;
            background: rgba(15, 23, 42, 0.8);
            box-shadow: 0 0 0 3px rgba(0, 212, 255, 0.2);
        }

        .search-btn {
            padding: 12px 24px;
            font-size: 1rem;
            background: linear-gradient(135deg, #00d4ff 0%, #007cf0 100%);
            border: none;
            border-radius: 8px;
            color: #fff;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .search-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 212, 255, 0.3);
        }

        .search-btn:active {
            transform: translateY(0);
        }

        .status-message {
            height: 24px;
            font-size: 0.9rem;
            color: #94a3b8;
            margin-bottom: 10px;
            transition: color 0.3s ease;
        }

        .status-message.error {
            color: #ef4444;
        }

        .map-container {
            background: rgba(255, 255, 255, 0.03);
            border-radius: 16px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        }

        .map-controls {
            position: absolute;
            top: 30px;
            right: 30px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 100;
        }

        .map-btn {
            width: 36px;
            height: 36px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(15, 23, 42, 0.9);
            color: #fff;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            transition: all 0.2s ease;
            backdrop-filter: blur(10px);
        }

        .map-btn:hover {
            background: rgba(59, 130, 246, 0.5);
            border-color: rgba(59, 130, 246, 0.6);
        }

        .map-btn:active {
            transform: scale(0.95);
        }

        .map-btn-reset {
            font-size: 0.7rem;
            font-weight: 600;
        }

        .zoom-info {
            position: absolute;
            bottom: 30px;
            left: 30px;
            background: rgba(15, 23, 42, 0.8);
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 0.75rem;
            color: #94a3b8;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        #map {
            cursor: grab;
        }

        #map.grabbing {
            cursor: grabbing;
        }

        #map.zooming {
            cursor: zoom-in;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #8892b0;
            font-size: 1rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .loading-spinner {
            width: 20px;
            height: 20px;
            border: 2px solid #4a5568;
            border-top-color: #00d4ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        #map {
            width: 100%;
            height: auto;
            display: block;
        }

        .land {
            fill: #2d3a4f;
            stroke: #4a5568;
            stroke-width: 0.5;
            vector-effect: non-scaling-stroke;
        }

        .route {
            fill: none;
            stroke-width: 1.5;
            opacity: 0.4;
            cursor: pointer;
            transition: all 0.3s ease;
            vector-effect: non-scaling-stroke;
        }

        .route.domestic {
            stroke: #10b981;
        }

        .route.international {
            stroke: #f59e0b;
        }

        .route:hover {
            opacity: 1;
            stroke-width: 3;
        }

        .airport {
            cursor: pointer;
            transition: fill 0.2s ease, stroke 0.2s ease, stroke-width 0.2s ease;
            stroke: transparent;
            stroke-width: 0;
            vector-effect: non-scaling-stroke;
        }

        .airport:hover {
            stroke-width: 3px;
        }

        .airport.origin {
            fill: #ef4444;
        }

        .airport.origin:hover {
            stroke: rgba(239, 68, 68, 0.5);
            fill: #f87171;
        }

        .airport.destination {
            fill: #3b82f6;
        }

        .airport.destination:hover {
            stroke: rgba(59, 130, 246, 0.5);
            fill: #60a5fa;
        }

        .tooltip {
            position: fixed;
            background: rgba(15, 23, 42, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 12px 16px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
            z-index: 1000;
            max-width: 300px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
        }

        .tooltip.visible {
            opacity: 1;
        }

        .tooltip h3 {
            font-size: 1rem;
            margin-bottom: 6px;
            color: #fff;
        }

        .tooltip .airlines {
            font-size: 0.85rem;
            color: #94a3b8;
        }

        .tooltip .route-type {
            display: inline-block;
            font-size: 0.7rem;
            padding: 2px 8px;
            border-radius: 4px;
            margin-bottom: 8px;
            text-transform: uppercase;
            font-weight: 600;
        }

        .tooltip .route-type.domestic {
            background: rgba(16, 185, 129, 0.2);
            color: #10b981;
        }

        .tooltip .route-type.international {
            background: rgba(245, 158, 11, 0.2);
            color: #f59e0b;
        }

        .legend {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9rem;
            color: #94a3b8;
        }

        .legend-line {
            width: 30px;
            height: 3px;
            border-radius: 2px;
        }

        .legend-line.domestic {
            background: #10b981;
        }

        .legend-line.international {
            background: #f59e0b;
        }

        .legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        .legend-dot.origin {
            background: #ef4444;
        }

        .legend-dot.destination {
            background: #3b82f6;
        }

        .stats {
            display: flex;
            justify-content: center;
            gap: 40px;
            margin-top: 25px;
            flex-wrap: wrap;
        }

        .stat {
            text-align: center;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: 700;
            background: linear-gradient(90deg, #00d4ff, #7b2cbf);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .stat-label {
            font-size: 0.85rem;
            color: #64748b;
            margin-top: 4px;
        }

        footer {
            text-align: center;
            padding: 30px 0 20px;
            color: #64748b;
            font-size: 0.8rem;
        }

        footer a {
            color: #3b82f6;
            text-decoration: none;
        }

        footer a:hover {
            text-decoration: underline;
        }
    </style>
</head>

<body>
    <div class="container">
        <header>
            <h1>Wiki Flight Map</h1>
            <p class="subtitle">Visualise direct flights from any airport using Wikipedia data</p>

            <div class="search-container">
                <input type="text" class="search-input" id="airport-search"
                    placeholder="Enter airport name (e.g. Heathrow Airport)" autocomplete="off">
                <button class="search-btn" id="search-btn">Map Flights</button>
            </div>
            <div class="status-message" id="status-message"></div>
        </header>

        <div class="map-container">
            <div class="loading" id="loading">
                <div class="loading-spinner"></div>
                <span>Loading map data...</span>
            </div>
            <div class="map-controls">
                <button class="map-btn" id="zoom-in" title="Zoom in">+</button>
                <button class="map-btn" id="zoom-out" title="Zoom out">−</button>
                <button class="map-btn map-btn-reset" id="zoom-reset" title="Reset view">⟲</button>
            </div>
            <div class="zoom-info" id="zoom-info">100%</div>
            <svg id="map" viewBox="0 0 1000 500" preserveAspectRatio="xMidYMid meet">
                <!-- World map paths will be added here -->
                <g id="countries"></g>
                <g id="routes"></g>
                <g id="airports"></g>
            </svg>
        </div>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-item">
                    <div class="legend-dot origin"></div>
                    <span id="legend-origin">Origin</span>
                </div>
                <div class="legend-item">
                    <div class="legend-dot destination"></div>
                    <span>Destinations</span>
                </div>
                <div class="legend-item">
                    <div class="legend-line domestic"></div>
                    <span>Domestic Routes</span>
                </div>
                <div class="legend-item">
                    <div class="legend-line international"></div>
                    <span>International Routes</span>
                </div>
            </div>

            <div class="stats">
                <div class="stat">
                    <div class="stat-value" id="domestic-count">0</div>
                    <div class="stat-label">Domestic Destinations</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="international-count">0</div>
                    <div class="stat-label">International Destinations</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="airline-count">0</div>
                    <div class="stat-label">Airlines</div>
                </div>
            </div>

            <footer>
                <p>Data sourced from <a href="https://en.wikipedia.org/wiki/Main_Page" target="_blank"
                        id="source-link">Wikipedia</a></p>
            </footer>
        </div>

        <div class="tooltip" id="tooltip"></div>

        <script>
            // State
            let currentOrigin = null;
            let currentDestinations = [];

            class WikiService {
                constructor() {
                    this.baseUrl = 'https://en.wikipedia.org/w/api.php';
                    this.userAgent = 'WikiFlights/1.0 (mailto:test@example.com)';
                }

                async search(query) {
                    console.log(`[WikiService] Searching for: "${query}"`);
                    const params = new URLSearchParams({
                        action: 'opensearch',
                        search: query,
                        limit: 10,
                        namespace: 0,
                        format: 'json',
                        origin: '*'
                    });

                    try {
                        const response = await fetch(`${this.baseUrl}?${params}`);
                        const data = await response.json();
                        // opensearch returns [query, [titles], [descriptions], [urls]]
                        const results = data[1].map((title, index) => ({
                            title: title,
                            url: data[3][index]
                        }));
                        console.log(`[WikiService] Search results for "${query}":`, results);
                        return results;
                    } catch (error) {
                        console.error('[WikiService] Search failed:', error);
                        return [];
                    }
                }

                async getAirportData(title) {
                    console.log(`[WikiService] Fetching airport data for: "${title}"`);

                    // We need two things:
                    // 1. Reliable coordinates (best from action=query)
                    // 2. HTML content to parse destinations (from action=parse)

                    const queryParams = new URLSearchParams({
                        action: 'query',
                        titles: title,
                        prop: 'coordinates|pageprops',
                        format: 'json',
                        origin: '*',
                        redirects: 1
                    });

                    const parseParams = new URLSearchParams({
                        action: 'parse',
                        page: title,
                        prop: 'text',
                        format: 'json',
                        origin: '*',
                        redirects: 1
                    });

                    try {
                        const [queryResp, parseResp] = await Promise.all([
                            fetch(`${this.baseUrl}?${queryParams}`),
                            fetch(`${this.baseUrl}?${parseParams}`)
                        ]);

                        const queryData = await queryResp.json();
                        const parseData = await parseResp.json();

                        // Process Coordinates
                        let coordinates = null;
                        let realTitle = title;

                        if (queryData.query && queryData.query.pages) {
                            const pages = Object.values(queryData.query.pages);
                            if (pages.length > 0) {
                                const page = pages[0];
                                realTitle = page.title; // Get the resolved title after redirects
                                if (page.coordinates) {
                                    coordinates = {
                                        lat: page.coordinates[0].lat,
                                        lon: page.coordinates[0].lon
                                    };
                                }
                            }
                        }

                        // Process HTML
                        let html = '';
                        if (parseData.parse && parseData.parse.text) {
                            html = parseData.parse.text['*'];
                            // If title changed in query (redirect), rely on query's title, 
                            // but parse usually handles its own redirects too.
                        } else {
                            console.warn(`[WikiService] No parse text returned for "${title}"`);
                        }

                        console.log(`[WikiService] Data fetched for "${realTitle}". Coordinates found: ${!!coordinates}`);

                        // We need both to be useful, but TECHNICALLY we could map the airport without destinations
                        // or have destinations without a map... but let's require coordinates for the Origin.

                        return {
                            title: realTitle,
                            html: html,
                            coordinates: coordinates
                        };

                    } catch (error) {
                        console.error('[WikiService] Failed to get airport data:', error);
                        return null;
                    }
                }

                parseDestinations(html) {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(html, 'text/html');

                    // Find the "Airlines and destinations" header
                    // It might be a simple H2, or wrapped in a div like <div class="mw-heading mw-heading2"><h2...>
                    const h2List = Array.from(doc.querySelectorAll('h2'));
                    let headerNode = null;

                    for (const h2 of h2List) {
                        if (h2.textContent.includes('Airlines and destinations') ||
                            h2.id === 'Airlines_and_destinations') {

                            // Check if wrapped in a MediaWiki heading div
                            if (h2.parentElement && h2.parentElement.classList.contains('mw-heading')) {
                                headerNode = h2.parentElement;
                            } else {
                                headerNode = h2;
                            }
                            console.log(`[WikiService] Found "Airlines and destinations" header anchor: <${headerNode.tagName}>`);
                            break;
                        }
                    }

                    if (!headerNode) {
                        console.warn('[WikiService] "Airlines and destinations" header not found.');
                        return [];
                    }

                    // Scan siblings for tables until the next H2
                    const destinationTables = [];
                    let currentNode = headerNode.nextElementSibling;
                    const maxNodesToCheck = 100; // Safety brake
                    let nodesChecked = 0;

                    while (currentNode && nodesChecked < maxNodesToCheck) {
                        const tag = currentNode.tagName;

                        // Stop if we hit the next major section (H2)
                        // Also check if it's a wrapper for H2
                        if (tag === 'H2') break;
                        if (tag === 'DIV' && currentNode.classList.contains('mw-heading2')) break;
                        if (currentNode.querySelector && currentNode.querySelector('h2')) break;

                        // Check if this node IS a table
                        if (tag === 'TABLE' && currentNode.classList.contains('wikitable')) {
                            destinationTables.push(currentNode);
                            console.log('[WikiService] Found flight table (sibling match)');
                        }
                        // Check if this node CONTAINS a table (e.g. wrapped in div)
                        else if (currentNode.querySelector) {
                            const tables = currentNode.querySelectorAll('table.wikitable');
                            if (tables.length > 0) {
                                tables.forEach(t => destinationTables.push(t));
                                console.log(`[WikiService] Found ${tables.length} nested flight table(s)`);
                            }
                        }

                        currentNode = currentNode.nextElementSibling;
                        nodesChecked++;
                    }

                    if (destinationTables.length === 0) {
                        console.warn('[WikiService] No "wikitable" found in "Airlines and destinations" section.');
                        return [];
                    }

                    console.log(`[WikiService] Found ${destinationTables.length} table(s) to parse.`);

                    // Parse all found tables
                    const destinations = [];

                    destinationTables.forEach((table, index) => {
                        const rows = table.querySelectorAll('tr');
                        console.log(`[WikiService] Parsing table #${index + 1} with ${rows.length} rows`);

                        let currentAirline = '';

                        rows.forEach(row => {
                            const cells = row.querySelectorAll('td');
                            if (cells.length === 0) return; // Skip header

                            let airlineCell, destCell;

                            // Typical structure: [Airline Name] [Destinations]
                            // Sometimes spans complicate things, but usually:
                            // If 2+ cells: Airline is first, Dests is second/last
                            // If 1 cell: Dests (continuation of previous airline)

                            // Note: Wikipedia tables are complex. 
                            // Standard flight table: Airline | Destinations
                            // Sometimes: Airline | Destinations | Notes (3 cols)

                            if (cells.length >= 2) {
                                airlineCell = cells[0];
                                // Identify destination cell - usually the last one or second one?
                                // In 2-col: index 1. In 3-col: index 1 is dests usually.
                                destCell = cells[1];

                                // Clean airline name, remove reference links [1]
                                currentAirline = airlineCell.textContent.replace(/\[.*?\]/g, '').trim();
                            } else if (cells.length === 1) {
                                destCell = cells[0];
                            }

                            if (!destCell || !currentAirline) return;

                            // Extract links
                            const links = destCell.querySelectorAll('a');
                            links.forEach(link => {
                                // Skip citations, broken links
                                if (link.href.includes('#cite') || link.classList.contains('new') || !link.title) return;

                                destinations.push({
                                    city: link.textContent.trim(),
                                    title: link.title,
                                    airline: currentAirline
                                });
                            });
                        });
                    });

                    console.log(`[WikiService] Parsed ${destinations.length} total destinations.`);
                    return destinations;
                }

                async getCoordinates(titles) {
                    console.log(`[WikiService] Fetching coordinates for ${titles.length} titles...`);
                    // Wikipedia API allows batching up to 50 titles
                    const chunks = [];
                    for (let i = 0; i < titles.length; i += 50) {
                        chunks.push(titles.slice(i, i + 50));
                    }

                    const results = {};

                    for (const chunk of chunks) {
                        const params = new URLSearchParams({
                            action: 'query',
                            titles: chunk.join('|'),
                            prop: 'coordinates',
                            format: 'json',
                            origin: '*'
                        });

                        try {
                            const response = await fetch(`${this.baseUrl}?${params}`);
                            const data = await response.json();

                            if (data.query && data.query.pages) {
                                Object.values(data.query.pages).forEach(page => {
                                    if (page.coordinates) {
                                        results[page.title] = {
                                            lat: page.coordinates[0].lat,
                                            lon: page.coordinates[0].lon
                                        };
                                    }
                                });
                            }
                        } catch (error) {
                            console.error('[WikiService] Batch coordinates fetch failed:', error);
                        }
                    }

                    console.log(`[WikiService] Resolved coordinates for ${Object.keys(results).length} / ${titles.length} titles`);
                    return results;
                }
            }

            const wikiService = new WikiService();
            // GeoJSON URL for Natural Earth 110m countries (local copy)
            const GEOJSON_URL = 'countries-110m.json';

            // Central meridian - centred on Pacific, adjusted to keep Europe/Africa visible
            // 160° keeps NZ on the right side while ensuring Europe/Africa aren't cut off at the left edge
            // Central meridian - dynamic based on airport location
            let CENTRAL_MERIDIAN = 160;

            // Convert lat/lon to SVG coordinates (Mercator-like projection centred on NZ)
            function latLonToXY(lat, lon) {
                // Shift longitude relative to central meridian and wrap
                let adjustedLon = lon - CENTRAL_MERIDIAN;
                // Normalize to -180 to 180 range
                while (adjustedLon > 180) adjustedLon -= 360;
                while (adjustedLon < -180) adjustedLon += 360;

                const x = (adjustedLon + 180) * (1000 / 360);
                const latRad = lat * Math.PI / 180;
                const mercN = Math.log(Math.tan((Math.PI / 4) + (latRad / 2)));
                const y = (500 / 2) - (1000 * mercN / (2 * Math.PI)) * 0.8;
                return { x, y: Math.max(20, Math.min(480, y)) };
            }

            // Convert a ring of coordinates [lon, lat] to SVG path
            function ringToPath(ring) {
                if (!ring || ring.length < 3) return '';

                const points = ring.map(([lon, lat]) => latLonToXY(lat, lon));

                // Check if polygon crosses the map edge
                let crossesEdge = false;
                for (let i = 1; i < points.length; i++) {
                    if (Math.abs(points[i].x - points[i - 1].x) > 500) {
                        crossesEdge = true;
                        break;
                    }
                }

                if (crossesEdge) {
                    // Split polygon at the edge - simplified approach
                    // Just skip small polygons that cross, render larger ones partially
                    return '';
                }

                let path = `M ${points[0].x.toFixed(1)} ${points[0].y.toFixed(1)}`;
                for (let i = 1; i < points.length; i++) {
                    path += ` L ${points[i].x.toFixed(1)} ${points[i].y.toFixed(1)}`;
                }
                path += ' Z';
                return path;
            }

            // Decode TopoJSON arc
            function decodeArc(topology, arcIndex) {
                const arc = topology.arcs[arcIndex < 0 ? ~arcIndex : arcIndex];
                const points = [];
                let x = 0, y = 0;

                for (const [dx, dy] of arc) {
                    x += dx;
                    y += dy;
                    points.push([
                        x * topology.transform.scale[0] + topology.transform.translate[0],
                        y * topology.transform.scale[1] + topology.transform.translate[1]
                    ]);
                }

                if (arcIndex < 0) {
                    points.reverse();
                }

                return points;
            }

            // Convert TopoJSON arcs to coordinates
            function arcsToCoordinates(topology, arcs) {
                const coordinates = [];
                for (const arcIndex of arcs) {
                    const decoded = decodeArc(topology, arcIndex);
                    // Avoid duplicate points at arc boundaries
                    if (coordinates.length > 0) {
                        decoded.shift();
                    }
                    coordinates.push(...decoded);
                }
                return coordinates;
            }

            // Convert TopoJSON geometry to SVG paths
            function geometryToSVGPaths(topology, geometry) {
                const paths = [];

                if (geometry.type === 'Polygon') {
                    for (const ring of geometry.arcs) {
                        const coords = arcsToCoordinates(topology, ring);
                        const path = ringToPath(coords);
                        if (path) paths.push(path);
                    }
                } else if (geometry.type === 'MultiPolygon') {
                    for (const polygon of geometry.arcs) {
                        for (const ring of polygon) {
                            const coords = arcsToCoordinates(topology, ring);
                            const path = ringToPath(coords);
                            if (path) paths.push(path);
                        }
                    }
                }

                return paths;
            }

            // Load and parse TopoJSON
            async function loadWorldMap() {
                try {
                    const response = await fetch(GEOJSON_URL);
                    if (!response.ok) throw new Error('Network response was not ok');
                    const topology = await response.json();

                    // Verify topology has required transform property
                    if (!topology.transform) {
                        throw new Error('Invalid TopoJSON format');
                    }

                    const paths = [];
                    const countries = topology.objects.countries;

                    if (countries.type === 'GeometryCollection') {
                        for (const geometry of countries.geometries) {
                            const countryPaths = geometryToSVGPaths(topology, geometry);
                            paths.push(...countryPaths);
                        }
                    }

                    return { success: true, paths };
                } catch (error) {
                    console.error('Failed to load world map:', error);
                    return { success: false, paths: [] };
                }
            }

            // Create curved path between two points
            function createCurvedPath(from, to) {
                const start = latLonToXY(from.lat, from.lon);
                const end = latLonToXY(to.lat, to.lon);

                // Handle paths that cross the map edge
                let endX = end.x;
                const directDist = Math.abs(end.x - start.x);
                const wrapDist = 1000 - directDist;

                if (wrapDist < directDist) {
                    // Path crosses edge, wrap around
                    if (end.x < start.x) {
                        endX = end.x + 1000;
                    } else {
                        endX = end.x - 1000;
                    }
                }

                const midX = (start.x + endX) / 2;
                const midY = (start.y + end.y) / 2;
                const dist = Math.sqrt(Math.pow(endX - start.x, 2) + Math.pow(end.y - start.y, 2));
                const curvature = Math.min(dist * 0.15, 60);

                // Curve upward (away from origin) for visual appeal
                const controlY = midY - curvature;

                return `M ${start.x} ${start.y} Q ${midX} ${controlY} ${endX} ${end.y}`;
            }

            // Initialize map
            async function initMap(origin, destinations) {
                const countriesGroup = document.getElementById('countries');
                const routesGroup = document.getElementById('routes');
                const airportsGroup = document.getElementById('airports');
                const tooltip = document.getElementById('tooltip');
                const loading = document.getElementById('loading');
                const statusMessage = document.getElementById('status-message');

                // Clear existing map
                routesGroup.innerHTML = '';
                airportsGroup.innerHTML = '';

                // If origin is provided, center map on it (with some offset logic)
                if (origin) {
                    // Try to keep the Pacific handy or center on the airport
                    // Standard Robinson usage is often 0, but for flight maps centered on the hub is good
                    // Actually, let's just shift so the airport is somewhat central but 
                    // we need to be careful about world wrapping. 
                    // Simple heuristic: origin.lon
                    CENTRAL_MERIDIAN = origin.lon;
                }

                // Load and draw world map from GeoJSON (only if paths empty or specific need)
                // But we need to redraw countries if CENTRAL_MERIDIAN changed because projection depends on it
                countriesGroup.innerHTML = ''; // Clear countries to redraw with new projection

                const result = await loadWorldMap();

                if (result.success && result.paths.length > 0) {
                    result.paths.forEach(pathData => {
                        const pathEl = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        pathEl.setAttribute('d', pathData);
                        pathEl.setAttribute('class', 'land');
                        countriesGroup.appendChild(pathEl);
                    });
                    // Hide loading indicator
                    if (loading) loading.style.display = 'none';
                } else {
                    // Show error state
                    if (loading) {
                        loading.innerHTML = '<span style="color: #ef4444;">⚠ Failed to load map data</span>';
                    }
                }

                // Draw routes
                destinations.forEach(flight => {
                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    path.setAttribute('d', createCurvedPath(origin, flight));
                    // Determine domestic/int based on checking country
                    // Ideally our data has this, but if not we guess
                    // Use flight.domestic property if available, otherwise check countries
                    const isDomestic = flight.country === origin.country;
                    flight.domestic = isDomestic;

                    path.setAttribute('class', `route ${isDomestic ? 'domestic' : 'international'}`);
                    path.setAttribute('data-city', flight.city);
                    path.setAttribute('data-code', flight.code || '');
                    path.setAttribute('data-country', flight.country || '');
                    path.setAttribute('data-airlines', flight.airlines ? flight.airlines.join(', ') : 'Unknown');
                    path.setAttribute('data-domestic', isDomestic);

                    path.addEventListener('mouseenter', showTooltip);
                    path.addEventListener('mousemove', moveTooltip);
                    path.addEventListener('mouseleave', hideTooltip);

                    routesGroup.appendChild(path);
                });

                // Draw Origin
                const originPos = latLonToXY(origin.lat, origin.lon);
                const originCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                originCircle.setAttribute('cx', originPos.x);
                originCircle.setAttribute('cy', originPos.y);
                originCircle.setAttribute('r', 6);
                originCircle.setAttribute('data-base-radius', 6);
                originCircle.setAttribute('class', 'airport origin');
                originCircle.setAttribute('data-city', origin.name || origin.title);
                originCircle.setAttribute('data-code', origin.code || '');
                originCircle.addEventListener('mouseenter', (e) => {
                    tooltip.innerHTML = `<h3>${origin.name || origin.title}</h3><div class="airlines">Origin</div>`;
                    tooltip.classList.add('visible');
                });
                originCircle.addEventListener('mousemove', moveTooltip);
                originCircle.addEventListener('mouseleave', hideTooltip);
                airportsGroup.appendChild(originCircle);

                // Draw destinations
                destinations.forEach(flight => {
                    const pos = latLonToXY(flight.lat, flight.lon);
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', pos.x);
                    circle.setAttribute('cy', pos.y);
                    circle.setAttribute('r', 4);
                    circle.setAttribute('data-base-radius', 4);
                    circle.setAttribute('class', 'airport destination');
                    circle.setAttribute('data-city', flight.city);
                    circle.setAttribute('data-code', flight.code || '');
                    circle.setAttribute('data-country', flight.country || '');
                    const displayAirlines = flight.airlines ? flight.airlines.join(', ') : 'Unknown';
                    circle.setAttribute('data-airlines', displayAirlines);
                    const isDomestic = flight.country === origin.country;
                    circle.setAttribute('data-domestic', isDomestic);

                    circle.addEventListener('mouseenter', showTooltip);
                    circle.addEventListener('mousemove', moveTooltip);
                    circle.addEventListener('mouseleave', hideTooltip);

                    airportsGroup.appendChild(circle);
                });

                // Update stats
                const domesticCount = destinations.filter(f => f.domestic).length; // Will be 0 if domestic undefined
                const internationalCount = destinations.filter(f => f.domestic === false).length;
                const airlines = new Set(destinations.flatMap(f => f.airlines));

                document.getElementById('domestic-count').textContent = destinations.some(d => d.domestic !== undefined) ? domesticCount : '-';
                document.getElementById('international-count').textContent = destinations.some(d => d.domestic !== undefined) ? internationalCount : '-';
                document.getElementById('airline-count').textContent = airlines.size;

                // Update Legend and Footer
                document.getElementById('legend-origin').textContent = origin.name || origin.title;
                const sourceLink = document.getElementById('source-link');
                sourceLink.href = `https://en.wikipedia.org/wiki/${origin.title}`;
                sourceLink.textContent = `Wikipedia - ${origin.title}`;
            }

            function showTooltip(e) {
                const target = e.target;
                const city = target.getAttribute('data-city');
                const code = target.getAttribute('data-code');
                const country = target.getAttribute('data-country');
                const airlines = target.getAttribute('data-airlines');
                const isDomestic = target.getAttribute('data-domestic') === 'true';

                const tooltip = document.getElementById('tooltip');
                tooltip.innerHTML = `
                <span class="route-type ${isDomestic ? 'domestic' : 'international'}">${isDomestic ? 'Domestic' : 'International'}</span>
                <h3>${city} (${code})</h3>
                <div class="airlines"><strong>Airlines:</strong> ${airlines}</div>
            `;
                tooltip.classList.add('visible');
            }

            function moveTooltip(e) {
                const tooltip = document.getElementById('tooltip');
                tooltip.style.left = (e.clientX + 15) + 'px';
                tooltip.style.top = (e.clientY + 15) + 'px';
            }

            function hideTooltip() {
                const tooltip = document.getElementById('tooltip');
                tooltip.classList.remove('visible');
            }

            // ==================== ZOOM & PAN FUNCTIONALITY ====================

            // Zoom/pan state
            const viewState = {
                x: 0,
                y: 0,
                width: 1000,
                height: 500,
                minZoom: 0.5,   // 50% zoom out max
                maxZoom: 8,     // 800% zoom in max
                zoomStep: 1.3   // 30% zoom per step
            };

            // Original viewBox dimensions
            const ORIGINAL_WIDTH = 1000;
            const ORIGINAL_HEIGHT = 500;

            // Get current zoom level as percentage
            function getZoomLevel() {
                return Math.round((ORIGINAL_WIDTH / viewState.width) * 100);
            }

            // Update viewBox and zoom display
            function updateViewBox() {
                const map = document.getElementById('map');
                const zoomInfo = document.getElementById('zoom-info');

                map.setAttribute('viewBox', `${viewState.x} ${viewState.y} ${viewState.width} ${viewState.height}`);
                zoomInfo.textContent = `${getZoomLevel()}%`;

                // Update airport circle sizes to maintain consistent screen size
                updateAirportSizes();
            }

            // Update airport circle radii based on zoom level
            // Icons scale with the map but have a minimum size to remain visible
            function updateAirportSizes() {
                const zoomLevel = ORIGINAL_WIDTH / viewState.width; // 1 = 100%, 2 = 200%, etc.
                const airports = document.querySelectorAll('.airport');

                airports.forEach(airport => {
                    const baseRadius = parseFloat(airport.getAttribute('data-base-radius')) || 4;
                    // Scale down as zoom increases, but maintain minimum visible size
                    const minRadius = baseRadius * 0.3; // Minimum 30% of base size
                    const scaledRadius = baseRadius / Math.sqrt(zoomLevel); // Gentle scaling
                    airport.setAttribute('r', Math.max(minRadius, scaledRadius));
                });
            }

            // Zoom to a specific point
            function zoomAtPoint(factor, clientX, clientY) {
                const map = document.getElementById('map');
                const rect = map.getBoundingClientRect();

                // Calculate the point in SVG coordinates
                const svgX = viewState.x + (clientX - rect.left) / rect.width * viewState.width;
                const svgY = viewState.y + (clientY - rect.top) / rect.height * viewState.height;

                // Calculate new dimensions
                const newWidth = viewState.width / factor;
                const newHeight = viewState.height / factor;

                // Check zoom limits
                const newZoom = ORIGINAL_WIDTH / newWidth;
                if (newZoom < viewState.minZoom || newZoom > viewState.maxZoom) {
                    return;
                }

                // Adjust position to zoom toward the point
                viewState.x = svgX - (svgX - viewState.x) / factor;
                viewState.y = svgY - (svgY - viewState.y) / factor;
                viewState.width = newWidth;
                viewState.height = newHeight;

                // Constrain to bounds
                constrainViewBox();
                updateViewBox();
            }

            // Zoom centered on the map
            function zoomCentered(factor) {
                const map = document.getElementById('map');
                const rect = map.getBoundingClientRect();
                zoomAtPoint(factor, rect.left + rect.width / 2, rect.top + rect.height / 2);
            }

            // Constrain viewBox to reasonable bounds
            function constrainViewBox() {
                // Allow some panning beyond the original bounds
                const padding = viewState.width * 0.1;
                const minX = -padding;
                const maxX = ORIGINAL_WIDTH - viewState.width + padding;
                const minY = -padding;
                const maxY = ORIGINAL_HEIGHT - viewState.height + padding;

                viewState.x = Math.max(minX, Math.min(maxX, viewState.x));
                viewState.y = Math.max(minY, Math.min(maxY, viewState.y));
            }

            // Reset to original view
            function resetView() {
                viewState.x = 0;
                viewState.y = 0;
                viewState.width = ORIGINAL_WIDTH;
                viewState.height = ORIGINAL_HEIGHT;
                updateViewBox();
            }

            // Initialize zoom and pan controls
            function initZoomPan() {
                const map = document.getElementById('map');
                const zoomIn = document.getElementById('zoom-in');
                const zoomOut = document.getElementById('zoom-out');
                const zoomReset = document.getElementById('zoom-reset');

                // Button controls
                zoomIn.addEventListener('click', () => zoomCentered(viewState.zoomStep));
                zoomOut.addEventListener('click', () => zoomCentered(1 / viewState.zoomStep));
                zoomReset.addEventListener('click', resetView);

                // Mouse wheel zoom
                map.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const factor = e.deltaY < 0 ? viewState.zoomStep : 1 / viewState.zoomStep;
                    zoomAtPoint(factor, e.clientX, e.clientY);
                }, { passive: false });

                // Pan with mouse drag
                let isPanning = false;
                let startX, startY;
                let startViewX, startViewY;

                map.addEventListener('mousedown', (e) => {
                    // Only pan with left mouse button
                    if (e.button !== 0) return;

                    isPanning = true;
                    startX = e.clientX;
                    startY = e.clientY;
                    startViewX = viewState.x;
                    startViewY = viewState.y;
                    map.classList.add('grabbing');
                    e.preventDefault();
                });

                document.addEventListener('mousemove', (e) => {
                    if (!isPanning) return;

                    const map = document.getElementById('map');
                    const rect = map.getBoundingClientRect();

                    // Calculate how much to pan in SVG coordinates
                    const dx = (e.clientX - startX) / rect.width * viewState.width;
                    const dy = (e.clientY - startY) / rect.height * viewState.height;

                    viewState.x = startViewX - dx;
                    viewState.y = startViewY - dy;

                    constrainViewBox();
                    updateViewBox();
                });

                document.addEventListener('mouseup', () => {
                    if (isPanning) {
                        isPanning = false;
                        const map = document.getElementById('map');
                        map.classList.remove('grabbing');
                    }
                });

                // Touch support for mobile
                let lastTouchDist = 0;
                let lastTouchCenter = { x: 0, y: 0 };

                map.addEventListener('touchstart', (e) => {
                    if (e.touches.length === 1) {
                        // Single touch - pan
                        isPanning = true;
                        startX = e.touches[0].clientX;
                        startY = e.touches[0].clientY;
                        startViewX = viewState.x;
                        startViewY = viewState.y;
                        map.classList.add('grabbing');
                    } else if (e.touches.length === 2) {
                        // Two touches - pinch zoom
                        isPanning = false;
                        const dx = e.touches[0].clientX - e.touches[1].clientX;
                        const dy = e.touches[0].clientY - e.touches[1].clientY;
                        lastTouchDist = Math.sqrt(dx * dx + dy * dy);
                        lastTouchCenter = {
                            x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
                            y: (e.touches[0].clientY + e.touches[1].clientY) / 2
                        };
                    }
                    e.preventDefault();
                }, { passive: false });

                map.addEventListener('touchmove', (e) => {
                    if (e.touches.length === 1 && isPanning) {
                        // Pan
                        const rect = map.getBoundingClientRect();
                        const dx = (e.touches[0].clientX - startX) / rect.width * viewState.width;
                        const dy = (e.touches[0].clientY - startY) / rect.height * viewState.height;

                        viewState.x = startViewX - dx;
                        viewState.y = startViewY - dy;

                        constrainViewBox();
                        updateViewBox();
                    } else if (e.touches.length === 2) {
                        // Pinch zoom
                        const dx = e.touches[0].clientX - e.touches[1].clientX;
                        const dy = e.touches[0].clientY - e.touches[1].clientY;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (lastTouchDist > 0) {
                            const factor = dist / lastTouchDist;
                            const centerX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                            const centerY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
                            zoomAtPoint(factor, centerX, centerY);
                        }

                        lastTouchDist = dist;
                    }
                    e.preventDefault();
                }, { passive: false });

                map.addEventListener('touchend', () => {
                    isPanning = false;
                    lastTouchDist = 0;
                    map.classList.remove('grabbing');
                });

                // Double click to zoom in
                map.addEventListener('dblclick', (e) => {
                    e.preventDefault();
                    zoomAtPoint(viewState.zoomStep * 1.5, e.clientX, e.clientY);
                });

                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    // Only handle if map container is in view
                    if (e.key === '+' || e.key === '=') {
                        zoomCentered(viewState.zoomStep);
                    } else if (e.key === '-') {
                        zoomCentered(1 / viewState.zoomStep);
                    } else if (e.key === '0') {
                        resetView();
                    }
                });
            }

            const searchInput = document.getElementById('airport-search');
            const searchBtn = document.getElementById('search-btn');
            const statusMessage = document.getElementById('status-message');
            const loading = document.getElementById('loading');

            // Handle search
            async function handleSearch() {
                const query = searchInput.value.trim();
                if (!query) return;

                console.group('Flight Search');
                console.log(`[App] Starting search for: "${query}"`);

                statusMessage.textContent = 'Searching...';
                statusMessage.className = 'status-message';

                // Clear previous map data slightly clearly
                document.getElementById('routes').innerHTML = '';
                document.getElementById('airports').innerHTML = '';

                try {
                    // 1. Search for airport
                    const results = await wikiService.search(query);
                    if (results.length === 0) {
                        console.warn('[App] Search returned no results');
                        statusMessage.textContent = 'No results found.';
                        statusMessage.className = 'status-message error';
                        console.groupEnd();
                        return;
                    }

                    // Just pick the first result for now
                    const bestMatch = results[0];
                    console.log(`[App] Best match selected: "${bestMatch.title}"`);
                    statusMessage.textContent = `Fetching data for ${bestMatch.title}...`;

                    // 2. Fetch airport main data
                    const airportData = await wikiService.getAirportData(bestMatch.title);
                    if (!airportData || !airportData.coordinates) {
                        console.error('[App] Failed to retrieve airport details or coordinates');
                        statusMessage.textContent = 'Could not find airport location data.';
                        statusMessage.className = 'status-message error';
                        console.groupEnd();
                        return;
                    }

                    const origin = {
                        title: airportData.title,
                        lat: airportData.coordinates.lat,
                        lon: airportData.coordinates.lon,
                        country: 'Unknown' // We'd need to parse the infobox for this, skipping for now or infer
                    };

                    statusMessage.textContent = `Parsing destinations...`;

                    // 3. Parse destinations
                    let destinations = wikiService.parseDestinations(airportData.html);
                    console.log(`[App] Parsed ${destinations.length} raw destinations from HTML`);

                    // Filter duplicate destinations
                    const uniqueDestinations = new Map();
                    destinations.forEach(desc => {
                        if (!uniqueDestinations.has(desc.title)) {
                            uniqueDestinations.set(desc.title, { ...desc, airlines: [desc.airline] });
                        } else {
                            // Merge airlines
                            const existing = uniqueDestinations.get(desc.title);
                            if (desc.airline && !existing.airlines.includes(desc.airline)) {
                                existing.airlines.push(desc.airline);
                            }
                        }
                    });

                    destinations = Array.from(uniqueDestinations.values());
                    console.log(`[App] Consolidated to ${destinations.length} unique destinations`);

                    if (destinations.length === 0) {
                        console.warn('[App] No destinations found in parsed data');
                        statusMessage.textContent = `Found airport but no flight routes in standard format.`;
                        statusMessage.className = 'status-message error';
                        // Draw just the origin?
                        initMap(origin, []);
                        console.groupEnd();
                        return;
                    }

                    statusMessage.textContent = `Locating ${destinations.length} destinations... (this may take a moment)`;

                    // 4. Batch geocode destinations
                    // This can take time for 100+ destinations
                    const titles = destinations.map(d => d.title);
                    const coordsMap = await wikiService.getCoordinates(titles);

                    // Combine data
                    const validRoutes = destinations.filter(d => coordsMap[d.title]).map(d => ({
                        city: d.city,
                        title: d.title,
                        lat: coordsMap[d.title].lat,
                        lon: coordsMap[d.title].lon,
                        airlines: d.airlines,
                        country: 'Unknown' // Wiki api doesn't give country easily in batch, would need more parsing
                    }));

                    console.log(`[App] Successfully mapped ${validRoutes.length} valid routes`);
                    statusMessage.textContent = `Mapped ${validRoutes.length} routes from ${origin.title}`;

                    // Render Map
                    await initMap(origin, validRoutes);

                    // Stats are updated inside initMap

                    console.groupEnd();

                } catch (e) {
                    console.error('[App] Main Error Handler:', e);
                    statusMessage.textContent = 'An error occurred.';
                    statusMessage.className = 'status-message error';
                    console.groupEnd();
                }
            }

            searchBtn.addEventListener('click', handleSearch);
            searchInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') handleSearch();
            });

            // Initial load - don't load map automatically until searched
            // Or maybe load just the world map background?
            // Initial load - don't load map automatically until searched
            // Or maybe load just the world map background?
            // Initial load - don't load map automatically until searched
            // Or maybe load just the world map background?
            loadWorldMap().then(result => {
                console.log('[App] World map loaded:', result.success ? 'Success' : 'Failed');
                if (result.success && result.paths.length > 0) {
                    const countriesGroup = document.getElementById('countries');
                    result.paths.forEach(pathData => {
                        const pathEl = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        pathEl.setAttribute('d', pathData);
                        pathEl.setAttribute('class', 'land');
                        countriesGroup.appendChild(pathEl);
                    });
                    document.getElementById('loading').style.display = 'none';
                }
                initZoomPan();
            });
        </script>
</body>

</html>